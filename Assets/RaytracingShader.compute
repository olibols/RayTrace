 // Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float4x4 CameraToWorld;
float4x4 CameraInverse;
float4 LightDir;

Texture2D<float4> SkyboxTexture;
SamplerState sampler_SkyboxTexture;

StructuredBuffer<int> Blocks;

RWStructuredBuffer<float4> debug;

static const float PI = 3.14159265f;
static const int CHUNK_SIZE = 256;

bool test = false;

struct Ray
{
    float3 Origin;
    float3 Direction;
    float3 Energy;
};

struct VoxelHit
{
    int3 Position;
    int VoxelType;
};

struct RayHit
{
    float3 Position;
    float3 Normal;
    float Distance;
};

VoxelHit CreateVoxelHit(int3 position, int voxeltype)
{
    VoxelHit hit;
    hit.Position = position;
    hit.VoxelType = voxeltype;
    return hit;
}

RayHit CreateRayHit(float3 position, float3 normal, float distance)
{
    RayHit hit;
    hit.Position = position;
    hit.Normal = normal;
    hit.Distance = distance;
    return hit;
}

Ray CreateRay(float3 Origin, float3 Direction)
{
    Ray ray;
    ray.Origin = Origin;
    ray.Direction = Direction;
    ray.Energy = float3(1.0, 1.0, 1.0);
    return ray;
};

//Create the normalized ray in a direction for a given pixel
Ray CreateCameraRay(float2 pixel)
{
    float3 origin = mul(CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    float3 direction = mul(CameraInverse, float4(pixel, 0.0f, 1.0f)).xyz;
    direction = mul(CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);
	
    return CreateRay(origin, direction);
}

float GetBlock(int x, int y, int z)
{
    if (x < 0 || x > CHUNK_SIZE || y < 0 || y > CHUNK_SIZE || z < 0 || z > CHUNK_SIZE)
        return 0;
    return Blocks[x + CHUNK_SIZE * (y + CHUNK_SIZE * z)];
}

float DistanceToBox(float3 raypos, int3 pos)
{
    float3 q = abs(raypos - pos) - 0.5f;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float SDFIntersect(Ray ray, int3 pos)
{
    float depth = 0.0f;
    for (int i = 0; i < 30; i++)
    {
        float dist = DistanceToBox(ray.Origin + depth * ray.Direction, pos);
        depth += dist;
    }
    return depth;
}

VoxelHit VoxelIntersect(Ray ray)
{
    int3 currentvoxel = int3(floor(ray.Origin.x), floor(ray.Origin.y), floor(ray.Origin.z));
    
    int stepX, stepY, stepZ;
    float tMaxX, tMaxY, tMaxZ;
    float tDeltaX, tDeltaY, tDeltaZ;
    
    if (ray.Direction.x > 0)
    {
        stepX = 1;
        tMaxX = (currentvoxel.x + ray.Origin.x) / ray.Direction.x;
        tDeltaX = 1.0 / ray.Direction.x;
    }
    else
    {
        stepX = -1;
        tMaxX = ((currentvoxel.x - 1) + ray.Origin.x) / ray.Direction.x;
        tDeltaX = 1.0 / -ray.Direction.x;
    }
    
    if (ray.Direction.y > 0)
    {
        stepY = 1;
        tMaxY = (currentvoxel.y + ray.Origin.y) / ray.Direction.y;
        tDeltaY = 1.0 / ray.Direction.y;
    }
    else
    {
        stepY = -1;
        tMaxY = ((currentvoxel.y - 1) + ray.Origin.y) / ray.Direction.y;
        tDeltaY = 1.0 / -ray.Direction.y;
    }
    
    if (ray.Direction.z > 0)
    {
        stepZ = 1;
        tMaxZ = (currentvoxel.z + ray.Origin.z) / ray.Direction.z;
        tDeltaZ = 1.0 / ray.Direction.z;
    }
    else
    {
        stepZ = -1;
        tMaxZ = ((currentvoxel.z - 1) + ray.Origin.z) / ray.Direction.z;
        tDeltaZ = 1.0 / -ray.Direction.z;
    }
            
    for (int i = 0; i < 1000; i++)
    {
        if (tMaxX < tMaxY)
        {
            if (tMaxX < tMaxZ)
            {
                currentvoxel.x += stepX;
                tMaxX += tDeltaX;
            }
            else
            {
                currentvoxel.z += stepZ;
                tMaxZ += tDeltaZ;
            }
        }
        else
        {
            if (tMaxY < tMaxZ)
            {
                currentvoxel.y += stepY;
                tMaxY += tDeltaY;
            }
            else
            {
                currentvoxel.z += stepZ;
                tMaxZ += tDeltaZ;
            }
        }
        
        float block = GetBlock(currentvoxel.x, currentvoxel.y, currentvoxel.z);
        
        if (block != 0.0)
        {
            VoxelHit hit = CreateVoxelHit(currentvoxel, block);
            return hit;
        }
    }
    VoxelHit hit = CreateVoxelHit(int3(0, 0, 0), 0);
    return hit;
}

float map(float value, float low1, float high1, float low2, float high2)
{
    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);
}


float3 Shade(inout Ray ray, VoxelHit hit)
{
    if (hit.VoxelType == 0)
    {
        ray.Energy = 0.0f;
        
        float theta = acos(ray.Direction.y) / -PI;
        float phi = atan2(ray.Direction.x, -ray.Direction.z) / -PI * 0.5f;
        return SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
    }
    else
    {
        float3 SurfaceCol;
        if(hit.VoxelType == 1)
            SurfaceCol = float3(110.0f / 255.0f, 180.0f / 255.0f, 110.0f / 255.0f);
        
        if (hit.VoxelType == 2)
            SurfaceCol = float3(160.0f / 255.0f, 82.0f / 255.0f, 45.0f / 255.0f);
        
        /*float shadow = 0.0;
        float3 ShadowRayOrigin = hit.Position;
        float3 ShadowRayDirection = -LightDir.xyz;
        Ray ray = CreateRay(ShadowRayOrigin, ShadowRayDirection);
        if (VoxelIntersect(ray).VoxelType != 0)
        {
            shadow = 1.0;
        }*/
               
        //return lerp(SurfaceCol, SurfaceCol * 0.2, shadow);
        return SurfaceCol;

    }
}

float3 Render(Ray ray)
{
    float3 result = float3(0.0, 0.0, 0.0);
    VoxelHit hit = VoxelIntersect(ray);
    result = Shade(ray, hit);
    return result;
}

[numthreads(32, 32, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    float2 pixel = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);
	
    Ray ray = CreateCameraRay(pixel);
	
    float3 res = Render(ray);
    
    Result[id.xy] = float4(res, 0.0f);
}